---
title: "Case Study: Using letsRept"
author: "JoÃ£o Paulo dos Santos Vieira-Alencar"
date: "`r Sys.Date()`"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{Case Study: Using letsRept}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Updating nomenclature with letsRept

This article is dedicated to simulate a follow up, step-by-step of the case study presented in `Vieira-Alencar et al. (2025)`.

The data used in the examples are referenced and publicly available. A full repository dedicated for the paper reproducibility is accessible via: https://doi.org/10.5281/zenodo.16895979. Download the repo and execute the .Rproj file to keep the same code structure as shown herein.

I recommend installing the development version directly from GitHub, but a stable version is available on CRAN. Package `here` and `parallel` are suggested to follow this tutorial.

```{r}
#devtools::install_github("joao-svalencar/letsRept", ref="main", force=TRUE)
#install.packages("here")
#install.packages("parallel")
library(letsRept)
```

If you downloaded the repository and executed the .Rproj, then to load the example dataset from [Nogueira et al. (2019)](https://doi.org/10.2994/SAJH-D-19-00120.1) run:

```{.r, eval = FALSE}
# load Nogueira et al., (2019) Supp. Mat. Table S3 (georeferenced type localities)
atlas <- read.csv(here::here("data", "atlas.csv"))
```

In the manuscript, to introduce readers to some of the main functions of *letsRept* we showed an example of how to subset the Reptile Database to get taxonomic information from a given group, in a given region. 

```{.r, eval = FALSE}
link <- reptAdvancedSearch(location = "Brazil", higher = "snakes")
snakes_br <- reptSpecies(link, taxonomicInfo = TRUE, cores = (parallel::detectCores()-1))
head(snakes_br)
```

But for nomenclature update using the internal data `allReptiles` you can just run `reptCompare` without a second argument:

```{.r}
compare <- reptCompare(atlas$species)
table(compare$status)
```

The basic update that most other tools provide will just try to detect the current name for unmatched entries. To start with these cases we subset the database filtering only for the species that doesn't match the Reptile Database nomenclature:

```{.r}
review <- reptCompare(atlas$species, snakes_br$species, filter = "review") #38 unmatched names 
```

Now, to verify the suggestions of current nomenclature we parse this names to `reptSync`:

```{.r}
sync <- reptSync(review, solveAmbiguity = TRUE, cores = (parallel::detectCores()-1))
sync

table(sync$status)
```


```{r, echo = FALSE}
library(knitr)

# Create a data frame
tab <- data.frame(
  ambiguous = 3,
  merge = 2,
  updated = 33
)

# Render the table
kable(tab, align = "c")
```

Alright, now we know that most species names could be unambiguously updated but we do have 3 cases of ambiguous nomenclature and 2 cases of species that should me merged, possibly because of species lumping. Let's see who they are in a tidy way:

```{.r}
reptTidySyn(sync, filter = c("merge", "ambiguous"))
```

For \emph{Corallus hortulanus} two options emerged, \emph{Corallus cookii} and \emph{Corallus hortulana}.

Although it can be quite straightforward for some users (e.g. familiar with the studied species), to be able to decide which name is the most appropriate to use in our study we might need to check extra information.

Let's give a look in their accounts:

```{r}
reptSearch("Corallus cookii")
reptSearch("Corallus hortulana")
```

Carefully evaluating the species synonyms entry we can verify that "\emph{Corallus hortulanus}" is a true synonym only of \emph{Corallus hortulana}. In \emph{Corallus cookii} account the name \emph{Corallus hortulanus} is considered only a chresonym (identified with an emdash between the name and the reference). Besides that, \emph{Corallus cookii} has never been recorded in Brazil (see Distribution). Therefore the most likely correct name for \emph{Corallus hortulanus} is now \emph{Corallus hortulana}. Users can manually change the nomenclature in their datasets or can optionally substitute the name in the reptSync output:

```{r}
sync$RDB[syncl$query=="Corallus hortulanus"] <- "Corallus hortulana" #choosing name to keep from RDB
sync$status[sync$query=="Corallus hortulanus"] <- "updated" #changing the name status
```

A similar rationale can be used for the remaining species.

```{r}
reptSearch("Adelphostigma occipitalis")
reptSearch("Adelphostigma quadriocellata")
reptSearch("Eutrachelophis papilio")

reptSearch("Tachymenis ocellata")
reptSearch("Tachymenis trigonatus")

reptSearch("Liotyphlops ternetzii")

write.csv(snakes_names, here::here("outputs", "Table S1.csv"), row.names = FALSE)
```


# check for species taxonomic split

```{r, eval = FALSE}
matched <- reptCompare(atlas$species, snakes_br, filter = c("matched", "absent")) #372 unmatched names + 1 absent

split_check <- reptSplitCheck(matched, pubDate = 2019, cores = (parallel::detectCores()-1))

table(split_check$status)
```

Make a table, or print the output
#check_split: 19; up_to_date: 353

#to check check_split species:
```{r, eval = FALSE}
reptTidySyn(split_check, filter = c("check_split"))
```

```{r, eval = FALSE}
#Atractus
reptSpecies(reptAdvancedSearch(synonym = "Atractus badius"), taxonomicInfo = T)
reptSearch("Atractus akerios")

reptSpecies(reptAdvancedSearch(synonym = "Atractus major"), taxonomicInfo = T)
reptSearch("Atractus nawa", getRef = T)

reptSpecies(reptAdvancedSearch(synonym = "Atractus snethlageae"), taxonomicInfo = T)
reptSearch("Atractus snethlageae", getRef = T)

#Chironius
reptSpecies(reptAdvancedSearch(synonym = "Chironius bicarinatus"), taxonomicInfo = T)
reptSearch("Chironius dracomaris", getRef = T)
reptSearch("Chironius gouveai", getRef = T)


reptSpecies(reptAdvancedSearch(synonym = "Chironius carinatus"), taxonomicInfo = T)
reptSearch("Chironius nigelnoriegai", getRef = T)

#Oxybelis aeneus
reptSpecies(herpAdvancedSearch(synonym = "Oxybelis aeneus"), taxonomicInfo = T)
reptSearch("Oxybelis inkaterra", getRef = T)
reptSearch("Oxybelis koehleri", getRef = T)
reptSearch("Oxybelis rutherfordi", getRef = T)
```
